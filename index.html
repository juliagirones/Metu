<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Metu</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #f5f5dc; /* fondo beige suave */
    }
    canvas {
      display: block;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 0 20px;
    }
    .controls button {
      padding: 20px 30px;
      font-size: 1.2rem;
      border: none;
      border-radius: 10px;
      background-color: #000;
      color: #fff;
      opacity: 0.7;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div class="controls">
    <button id="duckBtn">Agacharse</button>
    <button id="jumpBtn">Saltar</button>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let ground = canvas.height - 100;
let gravity = 1;
let gameSpeed = 5;

const player = {
  x: 150,
  y: ground,
  width: 50,
  height: 50,
  velocityY: 0,
  jumping: false,
  ducking: false,
  draw() {
    ctx.beginPath();
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#000';
    ctx.rect(this.x, this.y - this.height, this.width, this.height);
    ctx.stroke();
  },
  update() {
    if (this.jumping) {
      this.velocityY += gravity;
      this.y += this.velocityY;

      if (this.y >= ground) {
        this.y = ground;
        this.jumping = false;
        this.velocityY = 0;
      }
    }
    if (this.ducking) {
      this.height = 30;
    } else {
      this.height = 50;
    }
  }
};

const obstacles = [];
function createObstacle() {
  const height = Math.random() < 0.5 ? 50 : 80;
  obstacles.push({
    x: canvas.width,
    y: ground,
    width: 30,
    height,
    draw() {
      ctx.beginPath();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#000';
      ctx.rect(this.x, this.y - this.height, this.width, this.height);
      ctx.stroke();
    },
    update() {
      this.x -= gameSpeed;
    }
  });
}

setInterval(createObstacle, 2000);

document.getElementById('jumpBtn').addEventListener('click', () => {
  if (!player.jumping) {
    player.jumping = true;
    player.velocityY = -18;
  }
});

document.getElementById('duckBtn').addEventListener('mousedown', () => {
  player.ducking = true;
});
document.getElementById('duckBtn').addEventListener('mouseup', () => {
  player.ducking = false;
});

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  player.update();
  player.draw();

  for (let i = obstacles.length - 1; i >= 0; i--) {
    const obs = obstacles[i];
    obs.update();
    obs.draw();

    if (obs.x + obs.width < 0) {
      obstacles.splice(i, 1);
    }
  }

  requestAnimationFrame(gameLoop);
}

gameLoop();

  </script>
</body>
</html>
