<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Metu - Nivel 1</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #f5f5dc; /* beige suave */
      font-family: Arial, sans-serif;
      user-select: none;
    }
    canvas {
      display: block;
      background: transparent;
      position: absolute;
      top: 0; left: 0;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 20;
    }
    .controls button {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      border: none;
      background-color: #000;
      color: #fff;
      font-weight: bold;
      font-size: 1.2rem;
      opacity: 0.8;
      box-shadow: 0 3px 8px rgba(0,0,0,0.5);
      touch-action: manipulation;
    }
    #startMessage {
      position: fixed;
      top: 40%;
      width: 100%;
      text-align: center;
      font-size: 4rem;
      font-weight: 900;
      color: #000;
      z-index: 30;
      user-select: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div class="controls" style="display:none;" id="controls">
    <button id="duckBtn">游붅</button>
    <button id="jumpBtn">拘勇</button>
  </div>

  <div id="startMessage">START</div>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const ground = canvas.height - 100;
  const gravity = 1;
  const gameSpeed = 6;
  const levelDuration = 60 * 1000; // 1 minuto en ms

  // Estado del juego
  let gameStarted = false;
  let levelStartTime = 0;
  let collectedCandies = 0;
  let showMermaidTail = false;

  // Jugador
  const player = {
    x: 150,
    y: ground,
    width: 50,
    height: 50,
    velocityY: 0,
    jumping: false,
    ducking: false,
    draw() {
      ctx.beginPath();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#000';
      ctx.rect(this.x, this.y - this.height, this.width, this.height);
      ctx.stroke();
    },
    update() {
      if (this.jumping) {
        this.velocityY += gravity;
        this.y += this.velocityY;
        if (this.y >= ground) {
          this.y = ground;
          this.jumping = false;
          this.velocityY = 0;
        }
      }
      this.height = this.ducking ? 30 : 50;
    }
  };

  // Obst치culos
  const obstacles = [];
  // Dulces
  const candies = [];

  // Crear obst치culos normales (altura 50) y bajos (altura 30) alternados
  function createObstacle() {
    // 50% chance bajo o normal
    const isLow = Math.random() < 0.4;
    obstacles.push({
      x: canvas.width,
      y: ground,
      width: 30,
      height: isLow ? 30 : 50,
      draw() {
        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#000';
        ctx.rect(this.x, this.y - this.height, this.width, this.height);
        ctx.stroke();
      },
      update() {
        this.x -= gameSpeed;
      },
      isLow
    });
  }

  // Crear candies al azar
  function createCandy() {
    // Tipos diferentes: c칤rculo, estrella, coraz칩n, luna (simple siluetas)
    const types = ['circle', 'star', 'heart', 'moon'];
    const type = types[Math.floor(Math.random() * types.length)];

    candies.push({
      x: canvas.width,
      y: ground - 80,
      size: 25,
      type,
      collected: false,
      draw() {
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.beginPath();
        switch (this.type) {
          case 'circle':
            ctx.arc(this.x + this.size/2, this.y + this.size/2, this.size/2, 0, Math.PI * 2);
            break;
          case 'star':
            drawStar(ctx, this.x + this.size/2, this.y + this.size/2, 5, this.size/2, this.size/4);
            break;
          case 'heart':
            drawHeart(ctx, this.x, this.y, this.size);
            break;
          case 'moon':
            drawMoon(ctx, this.x, this.y, this.size);
            break;
        }
        ctx.stroke();
      },
      update() {
        this.x -= gameSpeed;
      }
    });
  }

  // Dibujar estrella
  function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    let step = Math.PI / spikes;

    ctx.moveTo(cx, cy - outerRadius);
    for (let i = 0; i < spikes; i++) {
      x = cx + Math.cos(rot) * outerRadius;
      y = cy + Math.sin(rot) * outerRadius;
      ctx.lineTo(x, y);
      rot += step;

      x = cx + Math.cos(rot) * innerRadius;
      y = cy + Math.sin(rot) * innerRadius;
      ctx.lineTo(x, y);
      rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius);
  }

  // Dibujar coraz칩n
  function drawHeart(ctx, x, y, size) {
    const topCurveHeight = size * 0.3;
    ctx.moveTo(x + size / 2, y + size / 5);
    ctx.bezierCurveTo(
      x + size / 2, y,
      x, y,
      x, y + topCurveHeight
    );
    ctx.bezierCurveTo(
      x, y + (size + topCurveHeight) / 2,
      x + size / 2, y + (size + topCurveHeight) / 1.5,
      x + size / 2, y + size
    );
    ctx.bezierCurveTo(
      x + size / 2, y + (size + topCurveHeight) / 1.5,
      x + size, y + (size + topCurveHeight) / 2,
      x + size, y + topCurveHeight
    );
    ctx.bezierCurveTo(
      x + size, y,
      x + size / 2, y,
      x + size / 2, y + size / 5
    );
  }

  // Dibujar luna
  function drawMoon(ctx, x, y, size) {
    ctx.arc(x + size / 2, y + size / 2, size / 2, 0.2 * Math.PI, 1.8 * Math.PI);
    ctx.moveTo(x + size / 2 + 5, y + size / 2);
    ctx.arc(x + size / 2 + 10, y + size / 2, size / 2, 1.8 * Math.PI, 0.2 * Math.PI, true);
  }

  // Dibujar cola de sirena (silhouette)
  function drawMermaidTail() {
    const cx = canvas.width / 2;
    const cy = ground;
    ctx.beginPath();
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#000';
    // Simple cola: dos tri치ngulos unidos (como una V abierta)
    ctx.moveTo(cx - 40, cy);
    ctx.lineTo(cx, cy - 100);
    ctx.lineTo(cx + 40, cy);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx - 30, cy);
    ctx.lineTo(cx, cy - 80);
    ctx.lineTo(cx + 30, cy);
    ctx.stroke();
  }

  // Control botones
  document.getElementById('jumpBtn').addEventListener('click', () => {
    if (!player.jumping) {
      player.jumping = true;
      player.velocityY = -18;
    }
  });
  document.getElementById('duckBtn').addEventListener('touchstart', () => {
    player.ducking = true;
  });
  document.getElementById('duckBtn').addEventListener('touchend', () => {
    player.ducking = false;
  });
  document.getElementById('duckBtn').addEventListener('mousedown', () => {
    player.ducking = true;
  });
  document.getElementById('duckBtn').addEventListener('mouseup', () => {
    player.ducking = false;
  });

  // Variables para control de tiempo y nivel
  let obstacleTimer = 0;
  let candyTimer = 0;
  const obstacleInterval = 1500;
  const candyInterval = 2000;

  // Mensaje y countdown
  const startMessageDiv = document.getElementById('startMessage');
  const controlsDiv = document.getElementById('controls');

  function showStartCountdown() {
    let count = 3;
    startMessageDiv.textContent = 'START';
    controlsDiv.style.display = 'none';

    const interval = setInterval(() => {
      if (count > 0) {
        startMessageDiv.textContent = count;
        count--;
      } else {
        startMessageDiv.textContent = 'HALLOWEEN!';
        setTimeout(() => {
          startMessageDiv.style.display = 'none';
          controlsDiv.style.display = 'flex';
          gameStarted = true;
          levelStartTime = Date.now();
        }, 1000);
        clearInterval(interval);
      }
    }, 1000);
  }

  function checkCollision(rect1, rect2) {
    return !(rect2.x > rect1.x + rect1.width
